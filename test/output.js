var defs = {t11_v0:"template <typename T>\nconstexpr T pi = 3.141590;",t11_v1:"template <typename... >\nusing void_t = void;",t11_v2:"template <typename T, int ...  I>\nstruct holder {\n  using type = T;\n  int a[sizeof...(I)] = { I ... };\n};",t11_v3:"template <typename T, int ...  I>\nusing holder_t = typename holder<T, I...>::type;",t11_v4:"template <typename T, template<typename , typename... > typename C>\nstruct specialized {\n  template <typename... Us>\n  using type = C<T, Us ...>;\n};",t11_v5:"template <typename T, template<typename , typename... > typename C, typename... Us>\nusing specialized_t = typename specialized<T, C>::template type<Us ...>;",t11_v7:"template <typename T>\nstruct container {\n  T * begin() const;\n  T * end() const;\n};",t11_v8:"template <typename T>\nvoid __cdecl h(){\n  for (auto&& e : container<T>{}){\n    h<T>();\n    static_cast<const int *>(e);\n    const_cast<const int *>(e);\n    reinterpret_cast<const int *>(e);\n    dynamic_cast<const int *>(e);\n    auto i = T(10);\n    (void)i;\n    (void *)i;\n  }\n}",t11_v9:"template <typename F>\nclass invoker {\n  invoker(F f): func{std::move(f)}, a(10) {\n  }\n  invoker() = default;\n  invoker(const invoker &) = default;\n  invoker(invoker &&) = default;\n  invoker(int): func{}, a{std::forward<int &&>(10)} {\n  }\n  template <typename... Ts>\n  auto invoke(Ts &&...  args){\n    return func(std::forward<Ts>(args)...);\n  }\n  F func;\n  int a = std :: forward < int && > ( MSG_L_CONSTANT );\n};",t9_v0:"typedef int int_t;",t9_v1:"typedef int my_int;",t9_v2:"typedef void(* func_t)(int, char, ...);",t9_v3:"typedef void(* my_func_t)(int, void *, ...);",t16_v0:"extern void printf(...);",t11_v10:"template <typename T, int N>\nint __cdecl f(int a, char b){\n  int a;\n  std::forward<int &&>(10);\n  for (int i = 0; i != 10; ++i){\n    printf(\"%d \", i);\n  }\n  return a;\n}",t7_v4:"namespace impl {\n  namespace structs {\n    struct U {\n      inline U(int, char, void *, impl::structs::U *);\n      inline U(const impl::structs::U &) = default;\n      inline constexpr U(impl::structs::U &&) = default;\n      inline constexpr U();\n      inline U(int);\n      int a;\n      inline ~U() = default;\n    };\n  }\n  namespace templates {\n    template <typename... >\n    struct templ {\n      structs::U u;\n    };\n  }\n}",t7_v11:"namespace structs {\n  struct U {\n    inline U(int, char, void *, impl::structs::U *);\n    inline U(const impl::structs::U &) = default;\n    inline constexpr U(impl::structs::U &&) = default;\n    inline constexpr U();\n    inline U(int);\n    int a;\n    inline ~U() = default;\n  };\n}",t7_v13:"struct U {\n  inline U(int, char, void *, impl::structs::U *);\n  inline U(const impl::structs::U &) = default;\n  inline constexpr U(impl::structs::U &&) = default;\n  inline constexpr U();\n  inline U(int);\n  int a;\n  inline ~U() = default;\n};",t18_v5:"inline U(int, char, void *, impl::structs::U *);",t18_v6:"inline U(const impl::structs::U &) = default;",t18_v7:"inline constexpr U(impl::structs::U &&) = default;",t18_v8:"inline constexpr U();",t18_v9:"inline U(int);",t5_v5:"int a;",t19_v0:"inline ~U() = default;",t7_v12:"namespace templates {\n  template <typename... >\n  struct templ {\n    structs::U u;\n  };\n}",t11_v12:"template <typename... >\nstruct templ {\n  structs::U u;\n};",t8_v0:"enum class color : unsigned int {\n  red = 15,\n  blue = 160,\n  green = 240,\n};",t8_v1:"enum class count : int {\n  one = 1,\n  two = 2,\n  three = 3,\n};",t8_v2:"enum class implicit : int {\n  implicit_1 = 0,\n  implicit_2 = 1,\n  implicit_3 = 2,\n  implicit_4 = 3,\n};",t11_v11:"template <typename T>\nvoid __cdecl switcher(implicit i){\n  switch (T t {};i){\n    case implicit::implicit_1:{\n      for (auto&& e : container<T>{}){\n      }\n    }\n    break;\n    case implicit::implicit_2:break;\n    case implicit::implicit_3:break;\n    case implicit::implicit_4:break;\n    case 0:default:;\n  }\n}",t7_v5:"namespace m {\n  struct S {\n  };\n  extern void f(const int * const);\n  extern void f(char * const *);\n  extern void * g(const int);\n  extern m::S * g();\n  extern m::S * g(m::S * * const, m::S);\n}",t7_v15:"struct S {\n};",t16_v1:"extern void f(const int * const);",t16_v2:"extern void f(char * const *);",t16_v3:"extern void * g(const int);",t16_v4:"extern m::S * g();",t16_v5:"extern m::S * g(m::S * * const, m::S);",t7_v6:"namespace n {\n  extern void f();\n  extern int g();\n  extern long double h();\n  extern float i();\n  extern impl::structs::U j(impl::structs::U, impl::structs::U);\n  extern impl::templates::templ<int, char, unsigned int, double, __wchar_t> k();\n}",t16_v6:"extern void f();",t16_v7:"extern int g();",t16_v8:"extern long double h();",t16_v9:"extern float i();",t16_v10:"extern impl::structs::U j(impl::structs::U, impl::structs::U);",t16_v11:"extern impl::templates::templ<int, char, unsigned int, double, __wchar_t> k();",t7_v7:"namespace o {\n  struct S {\n    virtual int f(char) volatile const && = 0;\n    virtual int f(char) volatile const & = 0;\n    virtual int f(int) volatile const = 0;\n    virtual void f() const = 0;\n    static constexpr inline const int i = 10;\n  };\n  extern void f(int &);\n  extern void f(int &&);\n  extern const int & f(char &);\n  extern o::S & g(o::S &);\n  extern o::S && g(const o::S &, o::S &, o::S &&, const o::S &&);\n}",t7_v16:"struct S {\n  virtual int f(char) volatile const && = 0;\n  virtual int f(char) volatile const & = 0;\n  virtual int f(int) volatile const = 0;\n  virtual void f() const = 0;\n  static constexpr inline const int i = 10;\n};",t17_v2:"virtual int f(char) volatile const && = 0;",t17_v3:"virtual int f(char) volatile const & = 0;",t17_v4:"virtual int f(int) volatile const = 0;",t17_v5:"virtual void f() const = 0;",t2_v1:"static constexpr inline const int i = 10;",t16_v12:"extern void f(int &);",t16_v13:"extern void f(int &&);",t16_v14:"extern const int & f(char &);",t16_v15:"extern o::S & g(o::S &);",t16_v16:"extern o::S && g(const o::S &, o::S &, o::S &&, const o::S &&);",t7_v8:"namespace p {\n  extern inline int(* f())(int);\n  extern int f(void(*)(char));\n}",t16_v17:"extern inline int(* f())(int);",t16_v18:"extern int f(void(*)(char));",t7_v9:"namespace q {\n  using o::f;\n  using o::f;\n  using o::f;\n  struct A {\n  };\n  struct B {\n  };\n  struct C {\n  };\n  struct D : virtual public q::A, private q::B, public q::C {\n  };\n}",t23_v0:"using o::f;",t23_v1:"using o::f;",t23_v2:"using o::f;",t7_v17:"struct A {\n};",t7_v18:"struct B {\n};",t7_v19:"struct C {\n};",t7_v20:"struct D : virtual public q::A, private q::B, public q::C {\n};",t7_v10:"struct S {\n  template <typename T>\n  struct void_t { };\n  int a;\n  char b;\n};",t11_v15:"template <typename T>\nstruct void_t { };",t5_v3:"int a;",t5_v4:"char b;",t9_v4:"typedef ::S SS;",t7_v22:"namespace std {\n  template <typename _Ty>\n  [[nodiscard]] constexpr remove_reference_t<_Ty> && __cdecl move(_Ty && _Arg) noexcept{\n    return static_cast<remove_reference_t<_Ty> &&>(_Arg);\n  }\n  template <typename _Ty>\n  [[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> && _Arg) noexcept{\n    static_assert(!is_lvalue_reference_v<_Ty>,\"bad forward call\");\n    return static_cast<_Ty &&>(_Arg);\n  }\n  template <typename _Ty>\n  [[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> & _Arg) noexcept{\n    return static_cast<_Ty &&>(_Arg);\n  }\n  template <typename _Ty>\n  using remove_reference_t = typename remove_reference<_Ty>::type;\n  template <typename _Ty>\n  constexpr inline bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;\n  template <typename _Ty>\n  struct remove_reference {\n    using type = _Ty;\n  };\n  template <typename _Ty>\n  struct is_lvalue_reference : false_type { };\n  typedef std::bool_constant<0> false_type;\n  template <bool _Val>\n  using bool_constant = integral_constant<bool, _Val>;\n  template <typename _Ty, _Ty _Val>\n  struct integral_constant {\n    constexpr static _Ty value = _Val;\n    using value_type = _Ty;\n    using type = integral_constant;\n    constexpr __compileMark operator value_type() const noexcept{\n      return value;\n    }\n    [[nodiscard]] constexpr value_type operator()() const noexcept{\n      return value;\n    }\n  };\n}",t11_v18:"template <typename _Ty>\n[[nodiscard]] constexpr remove_reference_t<_Ty> && __cdecl move(_Ty && _Arg) noexcept{\n  return static_cast<remove_reference_t<_Ty> &&>(_Arg);\n}",t11_v16:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> && _Arg) noexcept{\n  static_assert(!is_lvalue_reference_v<_Ty>,\"bad forward call\");\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v17:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> & _Arg) noexcept{\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v19:"template <typename _Ty>\nusing remove_reference_t = typename remove_reference<_Ty>::type;",t11_v21:"template <typename _Ty>\nconstexpr inline bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;",t11_v20:"template <typename _Ty>\nstruct remove_reference {\n  using type = _Ty;\n};",t11_v22:"template <typename _Ty>\nstruct is_lvalue_reference : false_type { };",t9_v11:"typedef std::bool_constant<0> false_type;",t11_v24:"template <bool _Val>\nusing bool_constant = integral_constant<bool, _Val>;",t11_v23:"template <typename _Ty, _Ty _Val>\nstruct integral_constant {\n  constexpr static _Ty value = _Val;\n  using value_type = _Ty;\n  using type = integral_constant;\n  constexpr __compileMark operator value_type() const noexcept{\n    return value;\n  }\n  [[nodiscard]] constexpr value_type operator()() const noexcept{\n    return value;\n  }\n};",t7_v22:"namespace std {\n  template <typename _Ty>\n  [[nodiscard]] constexpr remove_reference_t<_Ty> && __cdecl move(_Ty && _Arg) noexcept{\n    return static_cast<remove_reference_t<_Ty> &&>(_Arg);\n  }\n  template <typename _Ty>\n  [[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> && _Arg) noexcept{\n    static_assert(!is_lvalue_reference_v<_Ty>,\"bad forward call\");\n    return static_cast<_Ty &&>(_Arg);\n  }\n  template <typename _Ty>\n  [[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> & _Arg) noexcept{\n    return static_cast<_Ty &&>(_Arg);\n  }\n  template <typename _Ty>\n  using remove_reference_t = typename remove_reference<_Ty>::type;\n  template <typename _Ty>\n  constexpr inline bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;\n  template <typename _Ty>\n  struct remove_reference {\n    using type = _Ty;\n  };\n  template <typename _Ty>\n  struct is_lvalue_reference : false_type { };\n  typedef std::bool_constant<0> false_type;\n  template <bool _Val>\n  using bool_constant = integral_constant<bool, _Val>;\n  template <typename _Ty, _Ty _Val>\n  struct integral_constant {\n    constexpr static _Ty value = _Val;\n    using value_type = _Ty;\n    using type = integral_constant;\n    constexpr __compileMark operator value_type() const noexcept{\n      return value;\n    }\n    [[nodiscard]] constexpr value_type operator()() const noexcept{\n      return value;\n    }\n  };\n}",t11_v18:"template <typename _Ty>\n[[nodiscard]] constexpr remove_reference_t<_Ty> && __cdecl move(_Ty && _Arg) noexcept{\n  return static_cast<remove_reference_t<_Ty> &&>(_Arg);\n}",t11_v16:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> && _Arg) noexcept{\n  static_assert(!is_lvalue_reference_v<_Ty>,\"bad forward call\");\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v17:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> & _Arg) noexcept{\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v19:"template <typename _Ty>\nusing remove_reference_t = typename remove_reference<_Ty>::type;",t11_v21:"template <typename _Ty>\nconstexpr inline bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;",t11_v20:"template <typename _Ty>\nstruct remove_reference {\n  using type = _Ty;\n};",t11_v22:"template <typename _Ty>\nstruct is_lvalue_reference : false_type { };",t9_v11:"typedef std::bool_constant<0> false_type;",t11_v24:"template <bool _Val>\nusing bool_constant = integral_constant<bool, _Val>;",t11_v23:"template <typename _Ty, _Ty _Val>\nstruct integral_constant {\n  constexpr static _Ty value = _Val;\n  using value_type = _Ty;\n  using type = integral_constant;\n  constexpr __compileMark operator value_type() const noexcept{\n    return value;\n  }\n  [[nodiscard]] constexpr value_type operator()() const noexcept{\n    return value;\n  }\n};",t11_v18:"template <typename _Ty>\n[[nodiscard]] constexpr remove_reference_t<_Ty> && __cdecl move(_Ty && _Arg) noexcept{\n  return static_cast<remove_reference_t<_Ty> &&>(_Arg);\n}",t11_v16:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> && _Arg) noexcept{\n  static_assert(!is_lvalue_reference_v<_Ty>,\"bad forward call\");\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v17:"template <typename _Ty>\n[[nodiscard]] constexpr _Ty && __cdecl forward(remove_reference_t<_Ty> & _Arg) noexcept{\n  return static_cast<_Ty &&>(_Arg);\n}",t11_v19:"template <typename _Ty>\nusing remove_reference_t = typename remove_reference<_Ty>::type;",t11_v21:"template <typename _Ty>\nconstexpr inline bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;",t11_v20:"template <typename _Ty>\nstruct remove_reference {\n  using type = _Ty;\n};",t11_v22:"template <typename _Ty>\nstruct is_lvalue_reference : false_type { };",t9_v11:"typedef std::bool_constant<0> false_type;",t11_v24:"template <bool _Val>\nusing bool_constant = integral_constant<bool, _Val>;",t11_v23:"template <typename _Ty, _Ty _Val>\nstruct integral_constant {\n  constexpr static _Ty value = _Val;\n  using value_type = _Ty;\n  using type = integral_constant;\n  constexpr __compileMark operator value_type() const noexcept{\n    return value;\n  }\n  [[nodiscard]] constexpr value_type operator()() const noexcept{\n    return value;\n  }\n};"};